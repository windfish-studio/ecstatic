defmodule Ecstatic.EventConsumer do
  @moduledoc false
  use GenStage
  require Logger

  alias Ecstatic.{Entity, Changes}

  def start_link(entity) do
    GenStage.start_link(__MODULE__, entity)
  end

  def init(entity) do
    {:ok, ticker_pid} = Ecstatic.Ticker.start_link()
    state = %{
      systems: Ecstatic.Store.System.get_systems(),
      entity_id: entity.id,
      ticker: ticker_pid
    }

    {:consumer, state,
     subscribe_to: [
       {
         Ecstatic.EventProducer,
         selector: fn {event_entity, _changes} ->
           event_entity.id == entity.id
         end,
         max_demand: 1,
         min_demand: 0
       }
     ]}
  end

  def systems_to_aspects(systems) do
    Enum.map(systems, fn s -> s.aspect() end)
  end

  # I can do [event] because I only ever ask for one.
  # event => {entity, %{changed: [], new: [], deleted: []}}

  def handle_events([{entity, %Changes{} = changes} = _event], _from, %{systems: systems} = state) do
    Logger.debug(Kernel.inspect(changes, pretty: true))
    trigger_condition_filter = aspect_should_trigger?(entity, changes)
    components_filter = change_has_valid_components?(changes)
    systems
    |> Enum.filter(trigger_condition_filter)
#    Logger.debug(inspect({"consumer, matching condition aspects: ", systems}))
    systems
    |> Enum.filter(components_filter)
#    Logger.debug(inspect({"consumer, filtered systems: ", systems}))

    changes = merge_changes(entity, changes)
    new_entity = Entity.apply_changes(entity, changes)

    Logger.debug(inspect({"consumer, filtered systems: ", systems}))
    Enum.each(systems, fn system ->
#      system.process(new_entity, changes, 0)  #delta is generated by the ticker
      case changes do

        %Changes{attached: attached, updated: [], removed: []} ->
          send(state.ticker, {:start_tick, entity.id, system})

        %Changes{attached: [], updated: updated, removed: []} ->
          case system.aspect().when do
            [every: :continuous, for: _] -> send({:tick, entity.id, system}, state)
            [every: t, for: _] when is_number(t) -> Process.send_after(state.ticker, {:tick, entity.id, system}, t)
          end

        %Changes{attached: [], updated: [], removed: removed} ->
          send(state.ticker, {:stop_tick, system})
      end
    end)

#    Enum.each(aspects_to_use, fn w ->
#      case Map.get(w, :ticker, nil) do
#        nil ->
#          w.system.process(new_entity, changes, 0)  #delta is generated by the ticker
#        opts when is_list(opts) ->
#          comp = Ecstatic.Entity.find_component(new_entity, w.component)
#          case w.component_lifecycle_hook do #Cycle. Non reactive
#            :updated ->
#              case opts[:every] do
#                :continuous -> send(state.ticker, {:tick, comp.id, new_entity.id, w.system})
#                t when is_number(t) ->
#                  Process.send_after(
#                    state.ticker,                 {:tick, comp.id, new_entity.id, w.system}, t)
#              end
#            :attached -> send(state.ticker, {:start_tick, comp.id, new_entity.id, w.system, opts})
#            :removed -> send(state.ticker, {:stop_tick, comp.id})
#          end
#      end
    {:noreply, [], state}
  end

  def change_has_valid_components?(changes) do
    Logger.debug(inspect({"change contains", changes}))
    fn system ->
      Logger.debug(inspect({"change contains input", system}))
      updated = Map.get(changes, :updated, [])
      Enum.all?(system.aspect().with, fn component -> Enum.any?(updated, fn c -> component == c.type() end) end)
      |> Kernel.&&(Enum.any?(system.aspect().without, fn component -> Enum.all?(updated, fn c -> component == c.type() end) end))
    end
  end

  def aspect_should_trigger?(entity, changes) do
    fn system ->
      case Map.get(system.aspect(), :when, nil) do
        [every: period, for: n_times] -> true
        fun -> true
      require Logger
      Logger.debug(inspect({"aspect should trigger: ", system.aspect()}))
#      cond do
#        Map.get(aspect, :ticker, nil) != nil -> true
#        Map.get(aspect, :callback, nil) != nil ->
#          aspect.callback.(
#            entity,
#            Enum.find(
#              Map.get(changes, aspect.component_lifecycle_hook),
#              fn component -> aspect.component == component.type end
#            )
#          )
      end
    end
  end

  @spec merge_changes(Entity.t(), Changes.t()) :: Changes.t()
  defp merge_changes(entity, new_changes) do
    changes_updated = Enum.map(new_changes.updated,
      fn new_c ->
          old_c = Enum.find(entity.components,
            fn old_c -> old_c.id == new_c.id end)
          {old_c, new_c}
      end)
    %Changes{attached: new_changes.attached, updated: changes_updated, removed: new_changes.removed}
  end
end
